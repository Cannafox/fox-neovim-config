Additional context is provided below.
This is my neovim config written purely in lua.
The configuration structure is:
```
├── init.lua
├── lua
│   ├── fox-neovim-config
│   │   ├── autocmds.lua
│   │   ├── lazy_nvim.lua
│   │   ├── mappings.lua
│   │   ├── plugins
│   │   │   ├── bigfile.lua
│   │   │   ├── catppuccin.lua
│   │   │   ├── cmp-ai.lua
│   │   │   ├── cmp-luasnip-choice.lua
│   │   │   ├── cmp-plugins.lua
│   │   │   ├── conform.lua
│   │   │   ├── dashboard.lua
│   │   │   ├── fidget.lua
│   │   │   ├── gitsigns.lua
│   │   │   ├── gp.lua
│   │   │   ├── indent-blankline.lua
│   │   │   ├── init.lua
│   │   │   ├── lazygit.lua
│   │   │   ├── leetcode.lua
│   │   │   ├── lsp-colors.lua
│   │   │   ├── lsp-lens.lua
│   │   │   ├── lualine.lua
│   │   │   ├── mason.lua
│   │   │   ├── meowboard.lua
│   │   │   ├── nvim-autopairs.lua
│   │   │   ├── nvim-cmp-lsp-rs.lua
│   │   │   ├── nvim-cmp.lua
│   │   │   ├── nvim-colorizer.lua
│   │   │   ├── nvim-dap.lua
│   │   │   ├── nvim-dap-python.lua
│   │   │   ├── nvim-dap-ui.lua
│   │   │   ├── nvim-lspconfig.lua
│   │   │   ├── nvim-surround.lua
│   │   │   ├── nvim-tree.lua
│   │   │   ├── nvim-treesitter-context.lua
│   │   │   ├── nvim-treesitter.lua
│   │   │   ├── nvim-ufo.lua
│   │   │   ├── rustaceanvim.lua
│   │   │   ├── telescope.lua
│   │   │   ├── trouble.lua
│   │   │   ├── undotree.lua
│   │   │   ├── which-key.lua
│   │   │   └── yanky.lua
│   │   └── settings.lua
│   └── fox-neovim-config.lua
├── README.md
└── venv
```
And here are the sources of all files:

find (pwd) -type f -name "*.lua" -exec sh -c 'echo {}; echo "```lua"; cat {}; echo "```" \;

/home/fox/Dotfiles/.config/nvim/lua/fox-neovim-config.lua
```lua
vim.g.mapleader = ' '
vim.g.maplocalleader = ' '

local lazypath = vim.fn.stdpath("data") .. "/lazy/lazy.nvim"
if not vim.uv.fs_stat(lazypath) then
  local lazyrepo = "https://github.com/folke/lazy.nvim.git"
  vim.fn.system({ "git", "clone", "--filter=blob:none", "--branch=stable", lazyrepo, lazypath })
end

vim.opt.rtp:prepend(lazypath)
local lazy_config = require("fox-neovim-config.lazy_nvim")

require("lazy").setup({
    { import = "fox-neovim-config.plugins" },
}, lazy_config)

require("fox-neovim-config.settings")
require("fox-neovim-config.autocmds")
vim.schedule(function()
    require("fox-neovim-config.mappings")
end)
```
/home/fox/Dotfiles/.config/nvim/lua/fox-neovim-config/plugins/bigfile.lua
```lua
local M = { "LunarVim/bigfile.nvim" }

function M.opts()
  return {
    filesize = 1,
    pattern = { "*" },
    features = {
      "indent_blankline",
      "illuminate",
      "lsp",
      "treesitter",
      "syntax",
      "matchparen",
      "vimopts",
      "filetype",
    }
  }
end

return M
```
/home/fox/Dotfiles/.config/nvim/lua/fox-neovim-config/plugins/nvim-dap.lua
```lua
local M = { 'mfussenegger/nvim-dap' }

return M
```
/home/fox/Dotfiles/.config/nvim/lua/fox-neovim-config/plugins/lsp-colors.lua
```lua
local M = { "folke/lsp-colors.nvim" }

-- M.event = "User FilePost"

function M.opts()
  return {
    Test = "pink",
    Error = "#FF10F0",
    Warning = "#AA00A0",
    Hint = "#1BAEFA",
    Information = "#5BCEFA",
  }
end

return M
```
/home/fox/Dotfiles/.config/nvim/lua/fox-neovim-config/plugins/lualine.lua
```lua
local venv_path = os.getenv("VIRTUAL_ENV")

local get_venv = function()
  if vim.bo.filetype ~= "python" then
    return { "" }
  end
  if venv_path == nil then
    return { "" }
  else
    return { vim.fn.fnamemodify(venv_path, ":t") }
  end
end

local get_active_lsp = function()
  local msg = "No LSP"
  -- local buf_ft = vim.api.nvim_get_option_value("filetype")
  local clients = vim.lsp.get_clients({ bufnr = 0 })
  if next(clients) == nil then
    return msg
  end

  for _, client in ipairs(clients) do
    ---@diagnostic disable-next-line: undefined-field
    local filetypes = client.config.filetypes
    if filetypes and vim.fn.index(filetypes, vim.bo.filetype) ~= -1 then
      return client.name
    end
  end
  return msg
end

local M = { "nvim-lualine/lualine.nvim" }

M.dependencies = {
  "nvim-tree/nvim-web-devicons",
  "Isrothy/lualine-diagnostic-message",
  -- "jim-at-jibba/micropython.nvim",
}

function M.opts()
  return {
    options = {
      theme = "catppuccin",
      icons_enabled = true,
      disabled_filetypes = { statusline = { "dashboard" }, winbar = { "dashboard" } },
    },
    sections = {
      lualine_a = { "mode" },
      lualine_b = {
        "branch",
        {
          "diff",
          source = function()
            local gitsigns = vim.b.gitsigns_status_dict
            if gitsigns then
              return {
                added = gitsigns.added,
                modified = gitsigns.changed,
                removed = gitsigns.removed,
              }
            end
          end,
        },
      },
      lualine_c = {
        { "diagnostics", sources = { "nvim_diagnostic" } },
        { "searchcount", maxcount = 999, timeout = 500 },
      },
      lualine_x = {
        "diagnostic-message",
        { get_active_lsp },
      },
      lualine_y = {
        { "progress", padding = { left = 1, right = 1 } },
        { 'location' },
      },
      lualine_z = {
        get_venv(),
        function()
          return os.date("%R")
        end,
      },
    },
    winbar = {
      lualine_a = {
        "tabs",
        "hostname",
      },
      lualine_b = {
        { "fileformat", symbols = { unix = " ", dos = " ", mac = " " } },
        { "encoding", fmt = string.upper },
        { "filesize" },
      },
      lualine_c = {
        { "filetype", icon_only = true, separator = "", padding = { left = 1, right = 0 } },
        {
          "filename",
          padding = { left = 0, right = 1 },
          symbols = { readonly = "[R]", modified = "[~]", unnamed = "[*]", newfile = "[+]" },
        },
      },
      lualine_x = {},
      lualine_y = {},
      lualine_z = {
        {
          "buffers",
          show_filename_only = true,
          mode = 2,
        },
      },
    },
    tabline = {},
    extensions = { "lazy", "mason", "mundo", "nvim-tree", "trouble" },
  }
end

function M.config(_, opts)
  local keymap = vim.keymap

  keymap.set("n", "gb", function()
    vim.cmd("LualineBuffersJump! " .. vim.v.count)
  end, { desc = "Jump to the buffer" })
  keymap.set("n", "gB", "<cmd>LualineBuffersJump $<CR>", { desc = "Jump to the last buffer" })

  local trouble = require("trouble")
  local symbols = trouble.statusline({
    mode = "symbols",
    groups = {},
    title = false,
    filter = { range = true },
    format = "{kind_icon}{symbol.name:Normal}",
    -- The following line is needed to fix the background color
    -- Set it to the lualine section you want to use
    hl_group = "lualine_c_normal",
  })
  table.insert(opts.winbar.lualine_c, {
    symbols.get,
    cond = symbols.has,
  })
  -- table.insert(opts.sections.lualine_c, {
  --   require("micropython_nvim").statusline,
  --   cond = package.loaded["micropython_nvim"] and require("micropython_nvim").exists,
  -- })

  require("lualine").setup(opts)
end

return M
```
/home/fox/Dotfiles/.config/nvim/lua/fox-neovim-config/plugins/telescope.lua
```lua
local M = { "nvim-telescope/telescope.nvim" }

M.branch = "0.1.x"
M.cmd = "Telescope"
-- M.event = "VimEnter"
M.dependencies = {
  "nvim-treesitter/nvim-treesitter",
  "nvim-telescope/telescope-file-browser.nvim",
  { 'nvim-telescope/telescope-fzf-native.nvim', build = 'make' },
  "nvim-telescope/telescope-project.nvim",
  "nvim-telescope/telescope-live-grep-args.nvim",
  "nvim-telescope/telescope-frecency.nvim",
  "nvim-telescope/telescope-dap.nvim",
  "debugloop/telescope-undo.nvim",
}

function M.opts()
  return {
    defaults = {
      prompt_prefix = "   ",
      selection_caret = " ",
      entry_prefix = " ",
      sorting_strategy = "ascending",
      layout_config = {
        horizontal = {
          prompt_position = "top",
          preview_width = 0.55,
        },
        width = 0.87,
        height = 0.80,
      },
      mappings = {
        n = {
          ["q"] = require("telescope.actions").close,
        },
      },
    },
    extensions_list = { "frecency", "project", "live_grep_args", "dap", "fzf" },
    extensions = {
      fzf = {
        fuzzy = true,
        override_generic_sorter = true,
        override_file_sorter = true,
        case_mode = "smart_case",
      }
    },
  }
end

function M.init()
  vim.keymap.set("n", "<leader>ff", require("telescope.builtin").find_files, { desc = "Find files" })
  vim.keymap.set("n", "<leader>fg",  require("telescope").extensions.live_grep_args.live_grep_args, { desc = "Grep files" } )
  vim.keymap.set("n", "<leader>fb", require("telescope.builtin").buffers, { desc = "Search buffers" })
  vim.keymap.set("n", "<leader>fh", require("telescope.builtin").help_tags, { desc = "Search help tags" })
end

function M.config(_, opts)
  local telescope = require("telescope")

  telescope.setup(opts)

  for _, extension in ipairs(opts.extensions_list) do
    telescope.load_extension(extension)
  end
end

return M
```
/home/fox/Dotfiles/.config/nvim/lua/fox-neovim-config/plugins/nvim-colorizer.lua
```lua
local M = { "norcalli/nvim-colorizer.lua" }

M.event = "VimEnter"

-- function M.opts()
--   return {
--     RGB = true,
--     RRGGBB = true,
--     names = true,
--     RRGGBBAA = true,
--     rgb_fn = true,
--     -- mode = "background"
--   }
-- end

return M
```
/home/fox/Dotfiles/.config/nvim/lua/fox-neovim-config/plugins/which-key.lua
```lua
local M = { "folke/which-key.nvim" }

M.event = "VeryLazy"

function M.opts()
  return {
    delay = 0,
    preset = "helix",
    icons = {
      mappings = vim.g.have_nerd_font,
      keys = vim.g.have_nerd_font and {}
    },
    spec = {
      { '<leader>c', group = '[C]ode', mode = { 'n', 'x' } },
      { '<leader>d', group = '[D]elete' },
      { '<leader>r', group = '[R]ename' },
      { '<leader>f', group = '[F]ind' },
      { '<leader>w', group = '[W]orkspace' },
      { '<leader>t', group = '[T]oggle' },
      { '<leader>h', group = 'Git [H]unk', mode = { 'n', 'v' } },
    },
    plugins = {
      marks = true,
      registers = true,
      spelling = {
        enable = true,
        suggestions = 20,
      },
      presets = {
        operators = true,
        motions = true,
        text_objects = true,
        windows = true,
        nav = true,
        z = true,
        g = true,
      },
    },
  }
end

function M.config(_, opts)
  require('which-key').setup(opts)
end

return M
```
/home/fox/Dotfiles/.config/nvim/lua/fox-neovim-config/plugins/nvim-ufo.lua
```lua
local M = { 'kevinhwang91/nvim-ufo' }

M.dependencies = 'kevinhwang91/promise-async'

function M.init()
  vim.o.foldcolumn = '0' -- '0' is not bad
  vim.o.foldlevel = 99 -- Using ufo provider need a large value, feel free to decrease the value
  vim.o.foldlevelstart = 99
  vim.o.foldenable = true
end

function M.config()
  local ufo = require("ufo")

  vim.keymap.set('n', 'zR', ufo.openAllFolds)
  vim.keymap.set('n', 'zM', ufo.closeAllFolds)
  vim.keymap.set('n', 'zr', ufo.openFoldsExceptKinds)
  vim.keymap.set('n', 'zm', ufo.closeFoldsWith)

  ufo.setup({
    provider_selector = function(bufnr, filetype, buftype)
        return {'treesitter', 'indent'}
    end
  })
end

return M
```
/home/fox/Dotfiles/.config/nvim/lua/fox-neovim-config/plugins/indent-blankline.lua
```lua
local rainbow_highlight =	{
  "RainbowRed", "RainbowYellow", "RainbowBlue", "RainbowOrange", "RainbowGreen", "RainbowViolet", "RainbowCyan"
}

local M = { "lukas-reineke/indent-blankline.nvim" }

M.dependencies = "HiPhish/rainbow-delimiters.nvim"
-- M.event = "User FilePost"

function M.opts()
  return {
    scope = { highlight = rainbow_highlight },
    exclude = { filetypes = { "dashboard", "help", "NvimTree" } },
  }
end

function M.init()
  local rainbow_delimiters = require("rainbow-delimiters")

  vim.g.rainbow_delimiters = {
    strategy = {
      [""] = rainbow_delimiters.strategy["global"],
      vim = rainbow_delimiters.strategy["local"],
    },
    query = {
      [""] = "rainbow-delimiters",
      lua = "rainbow-blocks",
    },
    priority = {
      [""] = 110,
      lua = 210,
    },
    highlight = rainbow_highlight,
  }
end

function M.config(_, opts)
  local ibl = require("ibl")
  local hooks = require("ibl.hooks")

  hooks.register(
    hooks.type.HIGHLIGHT_SETUP,
    function()
      vim.api.nvim_set_hl(0, "RainbowRed", { fg = "#E06C75" })
      vim.api.nvim_set_hl(0, "RainbowYellow", { fg = "#E5C07B" })
      vim.api.nvim_set_hl(0, "RainbowBlue", { fg = "#61AFEF" })
      vim.api.nvim_set_hl(0, "RainbowOrange", { fg = "#D19A66" })
      vim.api.nvim_set_hl(0, "RainbowGreen", { fg = "#98C379" })
      vim.api.nvim_set_hl(0, "RainbowViolet", { fg = "#C678DD" })
      vim.api.nvim_set_hl(0, "RainbowCyan", { fg = "#56B6C2" })
    end
  )
  ibl.setup(opts)

  hooks.register(hooks.type.SCOPE_HIGHLIGHT, hooks.builtin.scope_highlight_from_extmark)
end

return M
```
/home/fox/Dotfiles/.config/nvim/lua/fox-neovim-config/plugins/yanky.lua
```lua
local M = { "gbprod/yanky.nvim" }

function M.opts()
  return {
    preserve_cursor_position = { enabled = true }
  }
end

return M
```
/home/fox/Dotfiles/.config/nvim/lua/fox-neovim-config/plugins/gp.lua
```lua
local M = { "robitx/gp.nvim" }

function M.opts()
  local api_key_path = "/home/fox/.config/openai.token"

  return { openai_api_key = { "cat",  api_key_path} }
end

return M
```
/home/fox/Dotfiles/.config/nvim/lua/fox-neovim-config/plugins/catppuccin.lua
```lua
local M = { "catppuccin/nvim" }

M.name = "catppuccin"
M.priority = 1000

function M.opts()
  return {
    flavour = "mocha", -- latte, frappe, macchiato, mocha
    background = { -- :h background
      light = "latte",
      dark = "mocha",
    },
    transparent_background = true, -- disables setting the background color.
    show_end_of_buffer = true, -- shows the '~' characters after the end of buffers
    term_colors = true, -- sets terminal colors (e.g. `g:terminal_color_0`)
    dim_inactive = {
      enabled = true, -- dims the background color of inactive window
      shade = "dark",
      percentage = 0.33, -- percentage of the shade to apply to the inactive window
    },
    no_italic = false, -- Force no italic
    no_bold = false, -- Force no bold
    no_underline = false, -- Force no underline
    styles = {
      comments = { "italic" }, -- Change the style of comments
      conditionals = { "bold" },
      loops = { "bold" },
      functions = {},
      keywords = { "bold", "italic" },
      strings = { "italic" },
      variables = {},
      numbers = { "italic" },
      booleans = { "italic" },
      properties = { "bold" },
      types = { },
      operators = { "bold" },
      miscs = {}, -- Uncomment to turn off hard-coded styles
    },
    color_overrides = {},
    custom_highlights = {},
    default_integrations = true,
    integrations = {
      cmp = true,
      nvimtree = true,
      treesitter = true,
      dashboard = true,
      gitsigns = true,
      dropbar = {
        enabled = true,
        color_mode = true,
      },
      fidget = true,
      mason = true,
      native_lsp = {
        enabled = true,
        virtual_text = {
            errors = { "italic" },
            hints = { "italic" },
            warnings = { "italic" },
            information = { "italic" },
            ok = { "italic" },
        },
        underlines = {
            errors = { "undercurl" },
            hints = { "undercurl" },
            warnings = { "undercurl" },
            information = { "undercurl" },
            ok = { "undercurl" },
        },
        inlay_hints = {
            background = true,
        },
      },
      treesitter_context = true,
      ufo = true,
      rainbow_delimiters = true,
      telescope = {
          enabled = true,
      },
      lsp_trouble = true,
      which_key = true,
      semantic_tokens = false,
    }
  }
end

function M.config(_, opts)
  require("catppuccin").setup(opts)
  vim.cmd.colorscheme("catppuccin")
end

return M
```
/home/fox/Dotfiles/.config/nvim/lua/fox-neovim-config/plugins/mason.lua
```lua
local M = {  "williamboman/mason.nvim" }

local function get_default_servers()
  return {
    "lua_ls",
    "groovyls",
    "marksman",
    "pylsp",
    "jsonls",
    "bashls",
    "clangd",
    "cmake",
    "diagnosticls",
    "dockerls",
    "dotls",
    "yamlls",
    "vimls",
  }
end

M.dependencies = { "williamboman/mason-lspconfig.nvim" }

function M.opts()
  return {
    ui = {
      border = "rounded",
      icons = {
        package_installed = "✓",
        package_pending = "~",
        package_uninstalled = "✗"
      }
    },
    log_level = vim.log.levels.INFO,
    max_concurrent_installers = 4,
  }
end

function M.setup(_, opts)
  local mason = require("mason")
  local lspconfig = require("lspconfig")
  local mason_lspconfig = require("mason-lspconfig")
  local default_servers = get_default_servers()

  mason.setup(opts)
  mason_lspconfig.setup({
    ensure_installed = default_servers,
    automatic_installation = true,
  })
end

return M
```
/home/fox/Dotfiles/.config/nvim/lua/fox-neovim-config/plugins/nvim-dap-ui.lua
```lua
local M = { "rcarriga/nvim-dap-ui" }

M.dependencies = {
  "mfussenegger/nvim-dap",
  "nvim-neotest/nvim-nio"
}

return M
```
/home/fox/Dotfiles/.config/nvim/lua/fox-neovim-config/plugins/conform.lua
```lua
local M = { "stevearc/conform.nvim" }

M.event = "User FilePost"

function M.opts()
  local lua_formatters = { "luaformatter" }
  local python_formatters = { "isort", "black" }
  local rust_formatters = { "rustfmt" }
  local yaml_formatters = { "yamlfmt" }
  local all_formatters = { "codespell" }
  local on_save_formatters = {}

  return {
    formatters_by_ft = {
      lua = lua_formatters,
      python = python_formatters,
      rust = rust_formatters,
      yaml = yaml_formatters,
      ["*"] = all_formatters,
      ["_"] = on_save_formatters,
    },
    format_on_save = false,
  }
end

function M.config(_, opts)
  local conform = require("conform")
  conform.setup(opts)

  vim.keymap.set("n", "<leader>F", function()
    conform.format({ bufnr = vim.api.nvim_get_current_buf() })
  end, { desc = "Format current buffer" })
end

return M
```
/home/fox/Dotfiles/.config/nvim/lua/fox-neovim-config/plugins/nvim-cmp.lua
```lua
local M = { "hrsh7th/nvim-cmp" }

M.dependencies = {
  "hrsh7th/cmp-buffer",
  "FelipeLema/cmp-async-path",
  "hrsh7th/cmp-nvim-lua",
  "hrsh7th/cmp-nvim-lsp",
  "hrsh7th/cmp-calc",
  { "mtoohey31/cmp-fish", ft = "fish" },
  "petertriho/cmp-git",
  "hrsh7th/cmp-cmdline",
  "lukas-reineke/cmp-rg",
  "hrsh7th/cmp-nvim-lsp-document-symbol",
  "hrsh7th/cmp-nvim-lsp-signature-help",
  { "L3MON4D3/LuaSnip", build = "make install_jsregexp" },
  { "windwp/nvim-autopairs" },
  "rafamadriz/friendly-snippets",
  "onsails/lspkind.nvim",
  "doxnit/cmp-luasnip-choice",
  "KadoBOT/cmp-plugins",
  "saadparwaiz1/cmp_luasnip",
  "ray-x/cmp-treesitter",
  "williamboman/mason-lspconfig.nvim",
  "chrisgrieser/cmp_yanky",
  "tzachar/cmp-ai",
  "zjp-CN/nvim-cmp-lsp-rs",
  "quangnguyen30192/cmp-nvim-tags",
  "delphinus/cmp-ctags",
}

function M.opts()
  local cmp_status_ok, cmp = pcall(require, "cmp")
  if not cmp_status_ok then
    return
  end

  local cmp_lsp_rs = require("cmp_lsp_rs")
  local comparators = cmp_lsp_rs.comparators
  local compare = require("cmp").config.compare

  return {
    snippet = {
      expand = function(args)
        require("luasnip").lsp_expand(args.body)
      end,
    },
    sorting = {
      comparators = {
        compare.exact,
        compare.score,
        -- comparators.inherent_import_inscope,
        comparators.inscope_inherent_import,
        comparators.sort_by_label_but_underscore_last,
      },
    },
    formatting = {
      fields = { "kind", "abbr", "menu" },
      format = require("lspkind").cmp_format({
        with_text = "true", -- show only symbol annotations
        maxwidth = 50, -- prevent the popup from showing more than provided characters (e.g 50 will not show more than 50 characters)
        ellipsis_char = "...", -- when popup menu exceed maxwidth, the truncated part would show ellipsis_char instead (must define maxwidth first)
        show_labelDetails = true, -- show labelDetails in menu. Disabled by default
        menu = {
          nvim_lsp = "[LSP]",
          luasnip = "[LuaSnip]",
          luasnip_choice = "[SnipChoice]",
          async_path = "[Path]",
          calc = "[Calc]",
          git = "[Git]",
          treesitter = "[TS]",
          cmp_lsp_rs = "[CmpRS]",
          nvim_lsp_signature_help = "[LspSig]",
          nvim_lsp_document_symbol = "[Symbol]",
          rg = "[Rg]",
          buffer = "[Buffer]",
          diag_codes = "[DiagCode]",
          plugins = "[Plugins]",
          fish = "[Fish]",
          cmp_ai = "[AI]",
          ctags = "[Ctags]",
          tags = "[Tags]",
        },
      }),
    },
    sources = cmp.config.sources({
      { name = "nvim_lsp" },
      { name = "luasnip_choice" },
      { name = "luasnip" },
      { name = "async_path" },
      { name = "calc" },
      { name = "git" },
      { name = "treesitter" },
      { name = "nvim_lsp_signature_help" },
      { name = "nvim_lsp_document_symbol" },
      { name = "diag-codes", option = { in_comment = true } },
      { name = "rg" },
      {
        name = "tags",
        option = {
          -- this is the default options, change them if you want.
          -- Delayed time after user input, in milliseconds.
          complete_defer = 100,
          -- Max items when searching `taglist`.
          max_items = 10,
          -- The number of characters that need to be typed to trigger
          -- auto-completion.
          keyword_length = 3,
          -- Use exact word match when searching `taglist`, for better searching
          -- performance.
          exact_match = false,
          -- Prioritize searching result for current buffer.
          current_buffer_only = false,
        },
      },
      {
        name = "ctags",
        option = {
          executable = "ctags",
          trigger_characters = { "." },
          trigger_characters_ft = {},
        },
      },
      { name = "buffer" },
      { name = "cmp_yanky" },
      { name = "plugins" },
      { name = "fish", option = { fish_path = "/usr/bin/fish" } },
      { name = "nvim-cmp-lsp-rs" },
    }),
    mapping = cmp.mapping.preset.insert({
      ["<Up>"] = cmp.mapping.select_prev_item(),
      ["<Down>"] = cmp.mapping.select_next_item(),

      ["<C-Up>"] = cmp.mapping.scroll_docs(-4),
      ["<C-Down>"] = cmp.mapping.scroll_docs(4),

      ["<C-Space>"] = cmp.mapping.complete(),
      ["<C-x>"] = cmp.mapping.complete({
        config = {
          sources = cmp.config.sources({
            { name = "cmp_ai" },
          }),
        },
      }),
      ["<C-e>"] = cmp.mapping.abort(),
      ["<CR>"] = cmp.mapping.confirm({ select = true }),
      ["<Tab>"] = cmp.mapping(function(fallback)
        local luasnip = require("luasnip")
        if cmp.visible() then
          cmp.select_next_item()
        elseif luasnip.expand_or_jumpable() then
          luasnip.expand_or_jump()
        else
          fallback()
        end
      end, { "i", "s" }),
      ["<S-Tab>"] = cmp.mapping(function(fallback)
        local luasnip = require("luasnip")
        if cmp.visible() then
          cmp.select_prev_item()
        elseif luasnip.jumpable(-1) then
          luasnip.jump(-1)
        else
          fallback()
        end
      end, { "i", "s" }),
    }),
    confirm_opts = {
      behavior = cmp.ConfirmBehavior.Replace,
      select = false,
    },
    experimental = {
      ghost_text = true,
    },
    window = {
      completion = cmp.config.window.bordered(),
      documentation = cmp.config.window.bordered(),
    },
  }
end

function M.config(_, opts)
  local cmp = require("cmp")

  local cmp_autopairs = require("nvim-autopairs.completion.cmp")
  local cmp_autopairs_handlers = require("nvim-autopairs.completion.handlers")
  local cmp_lsp_rs = require("cmp_lsp_rs")
  local comparators = cmp_lsp_rs.comparators
  local compare = require("cmp").config.compare
  opts.sorting.comparators = {
    compare.exact,
    compare.score,
    -- comparators.inherent_import_inscope,
    comparators.inscope_inherent_import,
    comparators.sort_by_label_but_underscore_last,
  }

  for _, source in ipairs(opts.sources) do
    cmp_lsp_rs.filter_out.entry_filter(source)
  end
  cmp.event:on(
    "confirm_done",
    cmp_autopairs.on_confirm_done({
      filetypes = {
        -- "*" is a alias to all filetypes
        ["*"] = {
          ["("] = {
            kind = {
              cmp.lsp.CompletionItemKind.Function,
              cmp.lsp.CompletionItemKind.Method,
            },
            handler = cmp_autopairs_handlers["*"],
          },
        },
        lua = {
          ["("] = {
            kind = {
              cmp.lsp.CompletionItemKind.Function,
              cmp.lsp.CompletionItemKind.Method,
            },
            ---@param char string
            ---@param item table item completion
            ---@param bufnr number buffer number
            ---@param rules table
            ---@param commit_character table<string>
            handler = function(char, item, bufnr, rules, commit_character)
              -- Your handler function. Inspect with print(vim.inspect{char, item, bufnr, rules, commit_character})
            end,
          },
        },
        -- Disable for tex
        tex = false,
      },
    })
  )

  require("luasnip.loaders.from_vscode").lazy_load()

  cmp.setup(opts)

  require("cmp_git").setup()

  cmp.setup.filetype("gitcommit", {
    sources = cmp.config.sources({
      { name = "git" },
    }, {
      { name = "buffer" },
    }),
  })
  cmp.setup.cmdline({ "/", "?" }, {
    mapping = cmp.mapping.preset.cmdline(),
    sources = {
      { name = "buffer" },
    },
  })
  cmp.setup.cmdline({ "/" }, {
    sources = cmp.config.sources({
      { name = "nvim_lsp_document_symbol" },
    }, {
      { name = "buffer" },
    }),
  })
  cmp.setup.cmdline({ ":" }, {
    mapping = cmp.mapping.preset.cmdline(),
    sources = cmp.config.sources({
      { name = "async_path" },
    }, {
      { name = "cmdline" },
    }),
    matching = { disallow_symbol_nonprefix_matching = false },
  })
end

return M
```
/home/fox/Dotfiles/.config/nvim/lua/fox-neovim-config/plugins/leetcode.lua
```lua
local M = { "kawre/leetcode.nvim" }

M.build = ":TSUpdate html"
M.dependencies = {
  "nvim-telescope/telescope.nvim",
  "nvim-lua/plenary.nvim",
  "MunifTanjim/nui.nvim",
}

function M.opts()
  return {
    lang = "python3"
  }
end

return M
```
/home/fox/Dotfiles/.config/nvim/lua/fox-neovim-config/plugins/meowboard.lua
```lua
local M = { "Cannafox/meowboard.nvim" }

function M.opts()
  return {
    verbose = true
  }
end

return M
```
/home/fox/Dotfiles/.config/nvim/lua/fox-neovim-config/plugins/nvim-treesitter-context.lua
```lua
local M = { "nvim-treesitter/nvim-treesitter-context" }

function M.opts()
  return {
    enable = true, -- Enable this plugin (Can be enabled/disabled later via commands)
    max_lines = 0, -- How many lines the window should span. Values <= 0 mean no limit.
    min_window_height = 0, -- Minimum editor window height to enable context. Values <= 0 mean no limit.
    line_numbers = true,
    multiline_threshold = 20, -- Maximum number of lines to show for a single context
    trim_scope = 'outer', -- Which context lines to discard if `max_lines` is exceeded. Choices: 'inner', 'outer'
    mode = 'cursor',  -- Line used to calculate context. Choices: 'cursor', 'topline'
    separator = nil,
    zindex = 20, -- The Z-index of the context window
    on_attach = nil, -- (fun(buf: integer): boolean) return false to disable attaching
  }
end

return M
```
/home/fox/Dotfiles/.config/nvim/lua/fox-neovim-config/plugins/lsp-lens.lua
```lua
local M = { "VidocqH/lsp-lens.nvim" }

function M.opts()
  local SymbolKind = vim.lsp.protocol.SymbolKind

  return {
    enable = true,
    include_declaration = false, -- Reference include declaration
    sections = { -- Enable / Disable specific request, formatter example looks 'Format Requests'
      definition = false,
      references = true,
      implements = true,
      git_authors = true,
    },
    ignore_filetype = { "prisma" },
    target_symbol_kinds = { SymbolKind.Function, SymbolKind.Method, SymbolKind.Interface },
    wrapper_symbol_kinds = { SymbolKind.Class, SymbolKind.Struct },
  }
end

return M
```
/home/fox/Dotfiles/.config/nvim/lua/fox-neovim-config/plugins/undotree.lua
```lua
local M = { "mbbill/undotree" }

function M.config()
  vim.keymap.set("n", "<leader>u", vim.cmd.UndotreeToggle, { desc = "Undotree" })
end

return M
```
/home/fox/Dotfiles/.config/nvim/lua/fox-neovim-config/plugins/cmp-ai.lua
```lua
local M = { "tzachar/cmp-ai" }

M.dependencies = {
  'nvim-lua/plenary.nvim'
}

function M.opts()
  return {
    max_lines = 1000,
    provider = 'OpenAI',
    provider_options = {
      model = 'gpt-4',
    },
    notify = true,
    notify_callback = function(msg)
      vim.notify(msg)
    end,
    run_on_every_keystroke = true,
    ignored_file_types = {
      -- default is not to ignore
      -- uncomment to ignore in lua:
      -- lua = true
    },
  }
end

function M.config(_, opts)
  local cmp_ai = require("cmp_ai.config")

  cmp_ai:setup(opts)
end

return M
```
/home/fox/Dotfiles/.config/nvim/lua/fox-neovim-config/plugins/cmp-plugins.lua
```lua
local M = { "KadoBOT/cmp-plugins" }

function M.opts()
  return {
    files = { "/home/fox/.config/nvim/lua/fox-neovim-config/plugins/" }
  }
end

function M.config(_, opts)
  require("cmp-plugins").setup(opts)
end

return M
```
/home/fox/Dotfiles/.config/nvim/lua/fox-neovim-config/plugins/nvim-dap-python.lua
```lua
local M = {	'mfussenegger/nvim-dap-python' }

M.dependencies = "mfussenegger/nvim-dap"

function M.config()
  require("dap-python").setup(vim.g.python3_host_prog)
end

return M
```
/home/fox/Dotfiles/.config/nvim/lua/fox-neovim-config/plugins/nvim-surround.lua
```lua
local M = {"kylechui/nvim-surround"}

M.version = "*"
M.event = "VeryLazy"

return M
```
/home/fox/Dotfiles/.config/nvim/lua/fox-neovim-config/plugins/nvim-cmp-lsp-rs.lua
```lua
local M = { "zjp-CN/nvim-cmp-lsp-rs" }

function M.opts()
  local compare = require("cmp").config.compare
  local comparators = require("cmp_lsp_rs").comparators
  return {
    -- Filter out import items starting with one of these prefixes.
    -- A prefix can be create name, module name or anything an import
    -- path starts with, no matter it's complete or incomplete.
    -- Only literals are recognized: no regex matching.
    unwanted_prefix = { "color", "ratatouille::style::Styled" },
    -- make these kinds prior to others
    -- e.g. make Module kind first, and then Function second,
    --      the rest ordering is merged from a default kind list
    kind = function(k)
      -- The argument in callback is type-aware with opts annotated,
      -- so you can type the CompletionKind easily.
      return { k.Module, k.Function }
    end,
    -- Override the default comparator list provided by this plugin.
    -- Mainly used with key binding to switch between these Comparators.
    combo = {
      -- The key is the name for combination of comparators and used
      -- in notification in swiching.
      -- The value is a list of comparators functions or a function
      -- to generate the list.
      alphabetic_label_but_underscore_last = function()
        return { comparators.sort_by_label_but_underscore_last }
      end,
      recentlyUsed_sortText = function()
        -- Mix cmp sorting function with cmp_lsp_rs.
        return {
          compare.recently_used,
          compare.sort_text,
          comparators.sort_by_label_but_underscore_last,
        }
      end,
    },
  }
end

return M
```
/home/fox/Dotfiles/.config/nvim/lua/fox-neovim-config/plugins/nvim-autopairs.lua
```lua
local M = { "windwp/nvim-autopairs" }

M.event = "InsertEnter"

function M.opts()
  return {
    disable_filetype = { "TelescopePrompt", "spectre_panel" },
    disable_in_macro = true, -- disable when recording or executing a macro
    disable_in_visualblock = false, -- disable when insert after visual block mode
    disable_in_replace_mode = true,
    ignored_next_char = [=[[%w%%%'%[%"%.%`%$]]=],
    enable_moveright = true,
    enable_afterquote = true, -- add bracket pairs after quote
    enable_check_bracket_line = true, --- check bracket in same line
    enable_bracket_in_quote = true, --
    enable_abbr = false, -- trigger abbreviation
    break_undo = true, -- switch for basic rule break undo sequence
    check_ts = true,
    ts_config = {
      lua = {'string'},-- it will not add a pair on that treesitter node
    },
    map_cr = true,
    map_bs = true, -- map the <BS> key
    map_c_h = false, -- Map the <C-h> key to delete a pair
    map_c_w = false, -- map <c-w> to delete a pair if possible
  }
end

function M.config(_, opts)
  local npairs = require("nvim-autopairs")
  local Rule = require('nvim-autopairs.rule')
  local ts_conds = require('nvim-autopairs.ts-conds')


  -- press % => %% only while inside a comment or string
  npairs.setup(opts)
  npairs.add_rules({
    Rule("%", "%", "lua")
      :with_pair(ts_conds.is_ts_node({'string','comment'})),
    Rule("$", "$", "lua")
      :with_pair(ts_conds.is_not_ts_node({'function'}))
  })
end

return M
```
/home/fox/Dotfiles/.config/nvim/lua/fox-neovim-config/plugins/init.lua
```lua
return {
  { "nvim-lua/plenary.nvim", lazy = true },
  { "nvim-tree/nvim-web-devicons", lazy = true },
  { 'echasnovski/mini.icons', version = false, lazy = true },
  { "MunifTanjim/nui.nvim", lazy = true },
}
```
/home/fox/Dotfiles/.config/nvim/lua/fox-neovim-config/plugins/gitsigns.lua
```lua
local M = { "lewis6991/gitsigns.nvim" }

M.event = "User FilePost"

function M.opts()
  local a = {}
  return {
    signs = {
      add = { text = "┃" },
      change = { text = "┃" },
      delete = { text = "_" },
      topdelete = { text = "‾" },
      changedelete = { text = "~" },
      untracked = { text = "┆" },
    },
    signs_staged = {
      add = { text = "┃" },
      change = { text = "┃" },
      delete = { text = "_" },
      topdelete = { text = "‾" },
      changedelete = { text = "~" },
      untracked = { text = "┆" },
    },
    signs_staged_enable = true,
    signcolumn = true, -- Toggle with `:Gitsigns toggle_signs`
    numhl = false, -- Toggle with `:Gitsigns toggle_numhl`
    linehl = false, -- Toggle with `:Gitsigns toggle_linehl`
    word_diff = false, -- Toggle with `:Gitsigns toggle_word_diff`
    watch_gitdir = {
      follow_files = true,
    },
    auto_attach = true,
    attach_to_untracked = true,
    current_line_blame = true, -- Toggle with `:Gitsigns toggle_current_line_blame`
    current_line_blame_opts = {
      virt_text = true,
      virt_text_pos = "eol", -- 'eol' | 'overlay' | 'right_align'
      delay = 1000,
      ignore_whitespace = false,
      virt_text_priority = 100,
      use_focus = true,
    },
    current_line_blame_formatter = "<author>, <author_time:%R> - <summary>",
    sign_priority = 6,
    update_debounce = 100,
    status_formatter = nil, -- Use default
    max_file_length = 40000, -- Disable if file is longer than this (in lines)
    preview_config = {
      -- Options passed to nvim_open_win
      border = "single",
      style = "minimal",
      relative = "cursor",
      row = 0,
      col = 1,
    },
  }
end

function M.config(_, opts)
  require("gitsigns").setup(opts)

  vim.api.nvim_create_autocmd("ColorScheme", {
    pattern = "*",
    callback = function()
      vim.cmd([[
          hi GitSignsChangeInline gui=reverse
          hi GitSignsAddInline gui=reverse
          hi GitSignsDeleteInline gui=reverse
        ]])
    end,
  })
end

return M
```
/home/fox/Dotfiles/.config/nvim/lua/fox-neovim-config/plugins/fidget.lua
```lua
local M = { "j-hui/fidget.nvim" }

function M.opts()
  return {
    notification = {
      poll_rate = 10,
      history_size = 512,
      override_vim_notify = true,
      window = {
        winblend = 0
      }
    },
  }
end

return M
```
/home/fox/Dotfiles/.config/nvim/lua/fox-neovim-config/plugins/nvim-tree.lua
```lua
local M = { "nvim-tree/nvim-tree.lua" }

M.cmd = { "NvimTreeToggle", "NvimTreeFocus" }

function M.opts()
  return {
    sort = {
      sorter = "case_sensitive",
    },
    view = {
      width = 30,
    },
    renderer = {
      group_empty = true,
    }
  }
end

return M
```
/home/fox/Dotfiles/.config/nvim/lua/fox-neovim-config/plugins/lazygit.lua
```lua
local M = { "kdheepak/lazygit.nvim" }

M.cmd = {
  "LazyGit",
  "LazyGitConfig",
  "LazyGitCurrentFile",
  "LazyGitFilter",
  "LazyGitFilterCurrentFile",
}

M.keys = {
  { "<leader>g", "<cmd>LazyGit<cr>", desc = "LazyGit" }
}

return M
```
/home/fox/Dotfiles/.config/nvim/lua/fox-neovim-config/plugins/dashboard.lua
```lua
local M = { "nvimdev/dashboard-nvim" }

M.event = "VimEnter"

function M.opts()
  local ascii_art = {
    "╔════════════════════════════════════╗",
    "║                                    ║",
    "║             ／＞-- フ              ║",
    "║            | 　_　_|  miau.        ║",
    "║          ／` ミ＿xノ               ║",
    "║        /　 　　 |                  ║",
    "║       /　  ヽ　|                   ║",
    "║       │　　 | ||   MIAU   ╱|、     ║",
    "║   ／￣|　　 | ||        (˚ˎ 。7    ║",
    "║  ( ￣ ヽ＿_ヽ_)__)       |、˜ |    ║",
    "║   ＼二)                  じしˍ,)ノ ║",
    "║                                    ║",
    "╚════════════════════════════════════╝",
  }

  return {
    theme = "hyper",
    config = {
      header = ascii_art,
      shortcut = {
        { desc = "Plugins", group = "@property", action = "Lazy", key = "p" },
        { desc = " Files", group = "Label", action = "Telescope find_files", key = "f" },
        { desc = " Apps", group = "DiagnosticHint", action = "Telescope app", key = "a" },
        { desc = " dotfiles", group = "Number", action = "Telescope dotfiles", key = "d" }
      }
    }
  }
end

return M
```
/home/fox/Dotfiles/.config/nvim/lua/fox-neovim-config/plugins/nvim-lspconfig.lua
```lua
local M = { "neovim/nvim-lspconfig" }

M.event = { "BufReadPre", "BufNewFile" }
M.dependencies = { "hrsh7th/cmp-nvim-lsp", "folke/neodev.nvim" }

function M.config()
  local lspconfig = require("lspconfig")
  local mason_lspconfig = require("mason-lspconfig")

  local on_attach = function(_, bufnr)
    local opts = { noremap = true, silent = true }

    vim.api.nvim_buf_set_keymap(bufnr, "n", "gD", "<cmd>lua vim.lsp.buf.declaration()<CR>", opts)
    vim.api.nvim_buf_set_keymap(bufnr, "n", "gd", "<cmd>lua vim.lsp.buf.definition()<CR>", opts)
    vim.api.nvim_buf_set_keymap(bufnr, "n", "gi", "<cmd>lua vim.lsp.buf.implementation()<CR>", opts)
    vim.api.nvim_buf_set_keymap(bufnr, "n",	"<leader>sh",	"<cmd>lua vim.lsp.buf.signature_help()<CR>", opts)
    vim.api.nvim_buf_set_keymap(bufnr, "n", "<leader>wa", "<cmd>lua vim.lsp.buf.add_workspace_folder()<CR>",	opts)
    vim.api.nvim_buf_set_keymap(bufnr, "n",	"<leader>wr",	"<cmd>lua vim.lsp.buf.remove_workspace_folder()<CR>", opts)
    vim.api.nvim_buf_set_keymap(bufnr, "n", "<leader>wl", "<cmd>lua function() print(vim.inspect(vim.lsp.buf.list_workspace_folders())) end()<CR>", opts)
    vim.api.nvim_buf_set_keymap(bufnr, "n",	"<leader>D", "<cmd>lua vim.lsp.buf.type_definition()<CR>",	opts)
    vim.api.nvim_buf_set_keymap(bufnr, "n", "<leader>ra", "<cmd>lua vim.lsp.buf.rename()<CR>", opts)
    vim.api.nvim_buf_set_keymap(bufnr, "n", "<leader>ca", "<cmd>lua vim.lsp.buf.code_action()<CR>",	opts)
    vim.api.nvim_buf_set_keymap(bufnr, "n", "gr", "<cmd>lua vim.lsp.buf.references()<CR>", opts)
  end

  local capabilities = vim.lsp.protocol.make_client_capabilities()
  capabilities = require("cmp_nvim_lsp").default_capabilities(capabilities)

  local signs = {
    { name = "DiagnosticSignError", text = "✘'" },
    { name = "DiagnosticSignWarn", text = "▲" },
    { name = "DiagnosticSignHint", text = "⚑" },
    { name = "DiagnosticSignInfo", text = "" },
  }

  for _, sign in ipairs(signs) do
    vim.fn.sign_define(sign.name, { texthl = sign.name, text = sign.text, numhl = "" })
  end

  local config = {
    virtual_text = true,
    signs = { active = signs },
    update_in_insert = false,
    underline = true,
    severity_sort = true,

  }
  vim.diagnostic.config(config)

  mason_lspconfig.setup_handlers({
    function(server_name)
      lspconfig[server_name].setup({
        capabilities = capabilities,
      })
    end,
    ["lua_ls"] = function()
      lspconfig["lua_ls"].setup({
        on_init = function(client)
          if client.workspace_folders then
            local path = client.workspace_folders[1].name
            if vim.uv.fs_stat(path..'/.luarc.json') or vim.uv.fs_stat(path..'/.luarc.jsonc') then
              return
            end
          end
        end,
        on_attach = on_attach,
        capabilities = capabilities,
        settings = {
          Lua = {
            runtime = { version = "LuaJIT" },
            diagnostics = {
              globals = { "vim" },
            },
            workspace = {
              library = {
                vim.fn.expand("$VIMRUNTIME/lua"),
                vim.fn.expand("$VIMRUNTIME/lua/vim/lsp"),
                vim.fn.stdpath("data") .. "/lazy/lazy.nvim/lua/lazy",
                "${3rd}/luv/library",
              },
            },
          },
        },
      })
    end,
    ["pylsp"] = function()
      local venv_path = os.getenv("VIRTUAL_ENV")
      local py_path = nil
      if venv_path ~= nil then
        py_path = venv_path .. "/bin/python3"
      else
        py_path = vim.g.python3_host_prog
      end
      lspconfig["pylsp"].setup({
        on_attach = on_attach,
        settings = {
          pylsp = {
            plugins = {
              -- formatter
              black = { enabled = true },
              pylint = { enabled = false, executable = "pylint", args = { "-d C0114,C0115,C0116" } },
              pylsp_mypy = {
                enabled = true,
                overrides = { "--python-executable", py_path, true },
                report_progress = true,
                live_mode = true,
              },
              pycodestyle = {
                ignore = { "W391" },
                maxLineLength = 100,
              },
              isort = { enabled = true },
            },
          },
        },
        capabilities = capabilities,
      })
    end,
    ["groovyls"] = function()
      lspconfig["groovyls"].setup({
        filetypes = { "groovy" },
        cmd = {
          "java",
          "-jar",
          "/home/gklodkox/sources/groovy-language-server/build/libs/groovy-language-server-all.jar",
        },
        on_attach = on_attach,
        capabilities = capabilities,
        settings = {
          groovy = {
            classpath = {
              vim.fn.expand("%"),
              string.gsub(vim.fn.system("git rev-parse --show-toplevel"), "\n", ""),
            },
          },
        },
      })
    end,
    ["rust_analyzer"] = function()
      lspconfig["rust_analyzer"].setup({
        filetypes = { "c", "cpp", "cc" },
        on_attach = on_attach,
        capabilities = capabilities,
        settings = {
          diagnostics = {
            enable = false,
          },
        },
      })
    end,
    ["clangd"] = function()
      lspconfig["clangd"].setup({
        filetypes = { "c", "cpp", "cc" },
        on_attach = on_attach,
        capabilities = capabilities,
      })
    end,
    ["bashls"] = function()
      lspconfig["bashls"].setup({
        on_attach = on_attach,
        capabilities = capabilities,
      })
    end,
    ["vimls"] = function()
      lspconfig["vimls"].setup({
        on_attach = on_attach,
        capabilities = capabilities,
      })
    end,
    ["dockerls"] = function()
      lspconfig["dockerls"].setup({
        on_attach = on_attach,
        settings = {
          docker = {
            languageserver = {
              formatter = {
                ignoreMultilineInstructions = true,
              },
            },
          },
        },
        capabilities = capabilities,
      })
    end
  })
end

return M
```
/home/fox/Dotfiles/.config/nvim/lua/fox-neovim-config/plugins/cmp-luasnip-choice.lua
```lua
local M = { "doxnit/cmp-luasnip-choice" }

function M.opts()
  return {
    auto_open = true
  }
end

return M
```
/home/fox/Dotfiles/.config/nvim/lua/fox-neovim-config/plugins/rustaceanvim.lua
```lua
local M = { "mrcjkb/rustaceanvim" }

M.version = "^5"
M.lazy = false

function M.init()
  vim.g.rustaceanvim = {
    -- Plugin configuration
    tools = {},
    -- LSP configuration
    server = {
      -- on_attach = function(client, bufnr)
      --   -- you can also put keymaps in here
      -- end,
      default_settings = {
        -- rust-analyzer language server configuration
        ["rust-analyzer"] = {},
      },
    },
    -- DAP configuration
    dap = {},
  }
end

return M
```
/home/fox/Dotfiles/.config/nvim/lua/fox-neovim-config/plugins/trouble.lua
```lua
local M = { "folke/trouble.nvim" }

M.cmd = "Trouble"
M.keys = {
  { "<leader>tt", "<cmd>Trouble diagnostics toggle<cr>", desc = "Diagnostics (Trouble)" },
  { "<leader>tT", "<cmd>Trouble diagnostics toggle filter.buf=0<cr>", desc = "Buffer Diagnostics (Trouble)" },
  {
    "<leader>tl",
    "<cmd>Trouble lsp toggle focus=false win.position=right<cr>",
    desc = "LSP Definitions / references / ... (Trouble)",
  },
  { "<leader>tL", "<cmd>Trouble loclist toggle<cr>", desc = "Location List (Trouble)" },
  { "<leader>tq", "<cmd>Trouble qflist toggle<cr>", desc = "Quickfix List (Trouble)" },
  { "<leader>[d", "<cmd>Trouble diagnostics next<cr>", desc = "Next diagnostic (Trouble)" },
  { "<leader>]d", "<cmd>Trouble diagnostics previous<cr>", desc = "Previous diagnostic (Trouble)" },
}

function M.opts()
  return {
    modes = {
      mydiags = {
        auto_open = false,
        auto_preview = true,
        pinned = true,
        warn_no_results = false,
        open_no_results = false,
        mode = "diagnostics", -- inherit from diagnostics mode
        filter = {
          any = {
            buf = 0, -- current buffer
            {
              severity = vim.diagnostic.severity.ERROR, -- errors only
              -- limit to files in the current project
              function(item)
                return item.filename:find((vim.loop or vim.uv).cwd(), 1, true)
              end,
            },
          },
        },
      },
      test = {
        mode = "diagnostics",
        preview = {
          type = "split",
          relative = "win",
          position = "right",
          size = 0.3,
        },
      },
    },
    -- modes = {
    --   diagnostics_buffer = {
    --     mode = "diagnostics", -- inherit from diagnostics mode
    --     filter = { buf = 0 }, -- filter diagnostics to the current buffer
    --     auto_close = false,
    --     auto_open = true,
    --     pinned = true,
    --     warn_no_results = false,
    --     open_no_results = true,
    --   },
    -- },
  }
end

return M
```
/home/fox/Dotfiles/.config/nvim/lua/fox-neovim-config/plugins/nvim-treesitter.lua
```lua
local M = { "nvim-treesitter/nvim-treesitter" }

M.build = ":TSUpdate"
M.dependencies = {
  "windwp/nvim-ts-autotag",
  "nvim-treesitter/nvim-treesitter-textobjects",
  "RRethy/nvim-treesitter-textsubjects",
  "LiadOz/nvim-dap-repl-highlights"
}

function M.opts()
  return {
    ensure_installed = {
      "vimdoc", "c", "lua", "rust",
      "jsdoc", "bash", "vim", "query", "markdown", "groovy",
      "markdown_inline", "python", "cpp", "fish", "dap_repl"
    },
    sync_install = false,
    ignore_install = {""},
    highlight = { enable =  true, additional_vim_regex_highlighting = false },
    indent = { enable = true },
    autotag = { enable = true },
    incremental_selection = {
      enable = true,
      keymaps = {
        init_selection = "<C-space>",
        node_incremental = "<C-space>",
        scope_incremental = false,
        node_decremental = "<bs>",
      },
    },
    context_commentstring = {
      enable = true,
      enable_autocmd = true,
    },
    textobjects = {
      enable = true,
      select = {
        keymaps = {
          -- You can use the capture groups defined in textobjects.scm
          ["a="] = { query = "@assignment.outer", desc = "Select outer part of an assignment" },
          ["i="] = { query = "@assignment.inner", desc = "Select inner part of an assignment" },
          ["l="] = { query = "@assignment.lhs", desc = "Select left hand side of an assignment" },
          ["r="] = { query = "@assignment.rhs", desc = "Select right hand side of an assignment" },

          ["aa"] = { query = "@parameter.outer", desc = "Select outer part of a parameter/argument" },
          ["ia"] = { query = "@parameter.inner", desc = "Select inner part of a parameter/argument" },

          ["ai"] = { query = "@conditional.outer", desc = "Select outer part of a conditional" },
          ["ii"] = { query = "@conditional.inner", desc = "Select inner part of a conditional" },

          ["al"] = { query = "@loop.outer", desc = "Select outer part of a loop" },
          ["il"] = { query = "@loop.inner", desc = "Select inner part of a loop" },

          ["af"] = { query = "@call.outer", desc = "Select outer part of a function call" },
          ["if"] = { query = "@call.inner", desc = "Select inner part of a function call" },

          ["am"] = { query = "@function.outer", desc = "Select outer part of a method/function definition" },
          ["im"] = { query = "@function.inner", desc = "Select inner part of a method/function definition" },

          ["ac"] = { query = "@class.outer", desc = "Select outer part of a class" },
          ["ic"] = { query = "@class.inner", desc = "Select inner part of a class" },
        },
      },
      swap = {
        enable = true,
        swap_next = {
          ["<leader>na"] = "@parameter.inner", -- swap parameters/argument with next
          ["<leader>nm"] = "@function.outer", -- swap function with next
        },
        swap_previous = {
          ["<leader>pa"] = "@parameter.inner", -- swap parameters/argument with prev
          ["<leader>pm"] = "@function.outer", -- swap function with previous
        },
      },
      move = {
        enable = true,
        set_jumps = true, -- whether to set jumps in the jumplist
        goto_next_start = {
          ["]f"] = { query = "@call.outer", desc = "Next function call start" },
          ["]m"] = { query = "@function.outer", desc = "Next method/function def start" },
          ["]c"] = { query = "@class.outer", desc = "Next class start" },
          ["]i"] = { query = "@conditional.outer", desc = "Next conditional start" },
          ["]l"] = { query = "@loop.outer", desc = "Next loop start" },

          -- You can pass a query group to use query from `queries/<lang>/<query_group>.scm file in your runtime path.
          -- Below example nvim-treesitter's `locals.scm` and `folds.scm`. They also provide highlights.scm and indent.scm.
          ["]s"] = { query = "@scope", query_group = "locals", desc = "Next scope" },
          ["]z"] = { query = "@fold", query_group = "folds", desc = "Next fold" },
        },
        goto_next_end = {
          ["]F"] = { query = "@call.outer", desc = "Next function call end" },
          ["]M"] = { query = "@function.outer", desc = "Next method/function def end" },
          ["]C"] = { query = "@class.outer", desc = "Next class end" },
          ["]I"] = { query = "@conditional.outer", desc = "Next conditional end" },
          ["]L"] = { query = "@loop.outer", desc = "Next loop end" },
        },
        goto_previous_start = {
          ["[f"] = { query = "@call.outer", desc = "Prev function call start" },
          ["[m"] = { query = "@function.outer", desc = "Prev method/function def start" },
          ["[c"] = { query = "@class.outer", desc = "Prev class start" },
          ["[i"] = { query = "@conditional.outer", desc = "Prev conditional start" },
          ["[l"] = { query = "@loop.outer", desc = "Prev loop start" },
        },
        goto_previous_end = {
          ["[F"] = { query = "@call.outer", desc = "Prev function call end" },
          ["[M"] = { query = "@function.outer", desc = "Prev method/function def end" },
          ["[C"] = { query = "@class.outer", desc = "Prev class end" },
          ["[I"] = { query = "@conditional.outer", desc = "Prev conditional end" },
          ["[L"] = { query = "@loop.outer", desc = "Prev loop end" },
        },
      },
    },
    textsubjects = { enable = true, prev_selection = ',', keymaps = {
          ['.'] = 'textsubjects-smart',
          [';'] = 'textsubjects-container-outer',
          ['i;'] = { 'textsubjects-container-inner', desc = "Select inside containers (classes, functions, etc.)" },
      }
    }
  }
end
function M.config(_, opts)
  require("nvim-dap-repl-highlights").setup()
  require("nvim-treesitter.configs").setup(opts)
end

return M
```
/home/fox/Dotfiles/.config/nvim/lua/fox-neovim-config/lazy_nvim.lua
```lua
return {
  defaults = { lazy = false },
  install = { colorscheme = { "catppuccin" } },
  ui = {
    icons = {
      ft = "",
      lazy = "󰂠 ",
      loaded = "",
      not_loaded = "",
    },
  },
  performance = {
    rtp = {
      disabled_plugins = {
        "tohtml",
        "gzip",
        "netrw",
        "netrwPlugin",
        "matchit",
        "tarPlugin",
        "zipPlugin",
        "tutor",
      },
    },
  },
  checker = { enabled = true }
}
```
/home/fox/Dotfiles/.config/nvim/lua/fox-neovim-config/mappings.lua
```lua
-- Explorator
vim.keymap.set("n", "\\", vim.cmd.NvimTreeToggle)

-- Dashboard
vim.keymap.set("n", "|", ":Dashboard<CR>")

-- Easy terminal escape
vim.keymap.set('t', '<Esc><Esc>', "<C-\\><C-n>", {desc = 'Exit terminal'})

-- Move lines
vim.keymap.set('v', '<S-Down>', ":m '>+1<CR>gv=gv")
vim.keymap.set('v', '<S-Up>', ":m '<-2<CR>gv=gv")

-- Clear hl on esc
vim.keymap.set('n', '<Esc>', ':nohlsearch<CR>')

vim.keymap.set('n', '<Home>', function()
    local col = vim.fn.col('.')
    local first_non_blank = vim.fn.match(vim.fn.getline('.'), '\\S') + 1
    return col == first_non_blank and '0' or '^'
end, { expr = true, silent = true })


```
/home/fox/Dotfiles/.config/nvim/lua/fox-neovim-config/autocmds.lua
```lua
-- user event that loads after UIEnter + only if file buf is there
vim.api.nvim_create_autocmd({ "UIEnter", "BufReadPost", "BufNewFile" }, {
  group = vim.api.nvim_create_augroup("NvFilePost", { clear = true }),
  callback = function(args)
    local file = vim.api.nvim_buf_get_name(args.buf)
    local buftype = vim.api.nvim_get_option_value("buftype", { buf = args.buf })

    if not vim.g.ui_entered and args.event == "UIEnter" then
      vim.g.ui_entered = true
    end

    if file ~= "" and buftype ~= "nofile" and vim.g.ui_entered then
      vim.api.nvim_exec_autocmds("User", { pattern = "FilePost", modeline = false })
      vim.api.nvim_del_augroup_by_name "NvFilePost"

      vim.schedule(function()
        vim.api.nvim_exec_autocmds("FileType", {})

        if vim.g.editorconfig then
          require("editorconfig").config(args.buf)
        end
      end)
    end
  end,
})

vim.api.nvim_create_autocmd({ "BufWritePre" }, {
  pattern = {"*"},
  callback = function()
    local view = vim.fn.winsaveview()
    vim.cmd [[%s:\s\+$::e]]
    vim.fn.winrestview(view) -- restore cached window view
  end,
})

vim.api.nvim_create_autocmd({ "BufRead" }, {
  pattern = "*",
  group = vim.api.nvim_create_augroup("non_utf8_file", { clear = true }),
  callback = function()
    if vim.bo.fileencoding ~= "utf-8" then
      vim.notify("File not in UTF-8 format!", vim.log.levels.WARN, { title = "nvim-config" })
    end
  end,
})

-- Automatically reload the file if it is changed outside of Nvim, see https://unix.stackexchange.com/a/383044/221410.
-- It seems that `checktime` does not work in command line. We need to check if we are in command
-- line before executing this command, see also https://vi.stackexchange.com/a/20397/15292 .
vim.api.nvim_create_augroup("auto_read", { clear = true })

vim.api.nvim_create_autocmd({ "FileChangedShellPost" }, {
  pattern = "*",
  group = "auto_read",
  callback = function()
    vim.notify("File changed on disk. Buffer reloaded!", vim.log.levels.WARN, { title = "nvim-config" })
  end,
})

vim.api.nvim_create_autocmd({ "FocusGained", "CursorHold" }, {
  pattern = "*",
  group = "auto_read",
  callback = function()
    if vim.fn.getcmdwintype() == "" then
      vim.cmd("checktime")
    end
  end,
})

-- Resize all windows when we resize the terminal
vim.api.nvim_create_autocmd("VimResized", {
  group = vim.api.nvim_create_augroup("win_autoresize", { clear = true }),
  desc = "autoresize windows on resizing operation",
  command = "wincmd =",
})
local function open_nvim_tree(data)
  -- check if buffer is a directory
  local directory = vim.fn.isdirectory(data.file) == 1

  if not directory then
    return
  end

  -- create a new, empty buffer
  vim.cmd.enew()

  -- wipe the directory buffer
  vim.cmd.bw(data.buf)

  -- open the tree
  require("nvim-tree.api").tree.open()
end

vim.api.nvim_create_autocmd({ "VimEnter" }, { callback = open_nvim_tree })
-- Do not use smart case in command line mode, extracted from https://vi.stackexchange.com/a/16511/15292.
vim.api.nvim_create_augroup("dynamic_smartcase", { clear = true })
vim.api.nvim_create_autocmd("CmdLineEnter", {
  group = "dynamic_smartcase",
  pattern = ":",
  callback = function()
    vim.o.smartcase = false
  end,
})

vim.api.nvim_create_autocmd("CmdLineLeave", {
  group = "dynamic_smartcase",
  pattern = ":",
  callback = function()
    vim.o.smartcase = true
  end,
})

vim.api.nvim_create_autocmd("TermOpen", {
  group = vim.api.nvim_create_augroup("term_start", { clear = true }),
  pattern = "*",
  callback = function()
    -- Do not use number and relative number for terminal inside nvim
    vim.wo.relativenumber = false
    vim.wo.number = false

    -- Go to insert mode by default to start typing command
    vim.cmd("startinsert")
  end,
})

-- Return to last cursor position when opening a file, note that here we cannot use BufReadPost
-- as event. It seems that when BufReadPost is triggered, FileType event is still not run.
-- So the filetype for this buffer is empty string.
vim.api.nvim_create_autocmd("FileType", {
  group = vim.api.nvim_create_augroup("resume_cursor_position", { clear = true }),
  pattern = "*",
  callback = function(ev)
    local mark_pos = vim.api.nvim_buf_get_mark(ev.buf, '"')
    local last_cursor_line = mark_pos[1]

    local max_line = vim.fn.line("$")
    local buf_filetype = vim.api.nvim_get_option_value("filetype", { buf = ev.buf })
    local buftype = vim.api.nvim_get_option_value("buftype", { buf = ev.buf })

    -- only handle normal files
    if buf_filetype == "" or buftype ~= "" then
      return
    end

    -- Only resume last cursor position when there is no go-to-line command (something like '+23').
    if vim.fn.match(vim.v.argv, [[\v^\+(\d){1,}$]]) ~= -1 then
      return
    end

    if last_cursor_line > 1 and last_cursor_line <= max_line then
      -- vim.print(string.format("mark_pos: %s", vim.inspect(mark_pos)))
      -- it seems that without vim.schedule, the cursor position can not be set correctly
      vim.schedule(function()
        local status, result = pcall(vim.api.nvim_win_set_cursor, 0, mark_pos)
        if not status then
          vim.api.nvim_err_writeln(string.format("Failed to resume cursor position. Context %s, error: %s",
          vim.inspect(ev), result))
        end
      end)
      -- the following two ways also seem to work,
      -- ref: https://www.reddit.com/r/neovim/comments/104lc26/how_can_i_press_escape_key_using_lua/
      -- vim.api.nvim_feedkeys("g`\"", "n", true)
      -- vim.fn.execute("normal! g`\"")
    end
  end,
})

local number_toggle_group = vim.api.nvim_create_augroup("numbertoggle", { clear = true })
vim.api.nvim_create_autocmd({ "BufEnter", "FocusGained", "InsertLeave", "WinEnter" }, {
  pattern = "*",
  group = number_toggle_group,
  desc = "togger line number",
  callback = function()
    if vim.wo.number then
      vim.wo.relativenumber = true
    end
  end,
})

vim.api.nvim_create_autocmd({ "BufLeave", "FocusLost", "InsertEnter", "WinLeave" }, {
  group = number_toggle_group,
  desc = "togger line number",
  callback = function()
    if vim.wo.number then
      vim.wo.relativenumber = false
    end
  end,
})

vim.api.nvim_create_autocmd("BufEnter", {
  pattern = "*",
  group = vim.api.nvim_create_augroup("auto_close_win", { clear = true }),
  desc = "Quit Nvim if we have only one window, and its filetype match our pattern",
  callback = function(_)
    local quit_filetypes = {'qf', 'NvimTree', 'trouble'}

    local should_quit = true
    local tabwins = vim.api.nvim_tabpage_list_wins(0)

    for _, win in pairs(tabwins) do
      local buf = vim.api.nvim_win_get_buf(win)
      local bf = vim.fn.getbufvar(buf, '&filetype')

      if vim.fn.index(quit_filetypes, bf) == -1 then
        should_quit = false
      end
    end

    if should_quit then
      vim.cmd("qall")
    end
  end
})

-- -- Auto save session
-- vim.api.nvim_create_autocmd({ 'BufWritePre' }, {
--   callback = function ()
--     for _, buf in ipairs(vim.api.nvim_list_bufs()) do
--       -- Don't save while there's any 'nofile' buffer open.
--       if vim.api.nvim_get_option_value("buftype", { buf = buf }) == 'nofile' then
--         return
--       end
--     end
--     require("session_manager").save_current_session()
--   end
-- })
--
-- local config_group = vim.api.nvim_create_augroup('MyConfigGroup', {}) -- A global group for all your config autocommands
--
-- vim.api.nvim_create_autocmd({ 'User' }, {
--   pattern = "SessionLoadPost",
--   group = config_group,
--   callback = function()
--     require('nvim-tree.api').tree.toggle(false, true)
--   end,
-- })
-- vim.api.nvim_create_autocmd('FileType', {
--   pattern = 'fish',
--   callback = function(args)
--     -- local match = vim.fs.find(root_markers, { path = args.file, upward = true })[1]
--     -- local root_dir = match and vim.fn.fnamemodify(match, ':p:h') or nil
--     vim.lsp.start {
--       cmd = { '/home/fox/Sources/fish-lsp/bin/fish-lsp', 'start' },
--       settings = {},
--     }
--   end,
-- })
```
/home/fox/Dotfiles/.config/nvim/lua/fox-neovim-config/settings.lua
```lua
local set_global = vim.g
local set_opt = vim.opt
local set_o = vim.o

-- GLOBALS
set_global.loaded_perl_provider = 0
set_global.loaded_ruby_provider = 0
set_global.python3_host_prog = vim.loop.os_homedir() .. '/.config/nvim/venv/bin/python3'
set_global.node_host_prog = '/usr/bin/neovim-node-host'
set_global.have_nerd_font = true
-- NUMBER LINE
set_o.number = true
set_o.relativenumber = true
set_o.cursorline = true
set_o.cursorlineopt = "both"
set_o.ruler = false
set_o.numberwidth = 2
-- INDENTS
set_o.expandtab = true
set_o.shiftwidth = 2
set_o.tabstop = 2
set_o.softtabstop = 2
set_o.smartindent = true
set_opt.breakindent = true
-- EDITOR
set_opt.list = true
set_opt.listchars = { trail = '·', nbsp = '␣' }
set_opt.ignorecase = true
set_opt.smartcase = true
set_opt.modelines = 5
set_opt.modeline = true
set_opt.showmode = false
set_opt.path = vim.opt.path + "**"
set_opt.equalalways = true
set_o.mouse = "a"
set_o.smoothscroll = true
set_o.clipboard = "unnamedplus"
set_o.title = true
set_o.inccommand = "split"
set_o.ttimeoutlen = 0
set_opt.timeoutlen = 300
set_o.updatetime = 250
set_o.wrap = false
set_opt.whichwrap:append "<>[hl]"
set_opt.shortmess:append "sI"
set_o.splitbelow = true
set_o.splitright = true
set_o.winheight = 3
set_o.scrolloff = 9
set_o.sidescrolloff = 4
set_o.signcolumn = "yes"
set_o.colorcolumn = "80"
-- BACKUP
set_o.swapfile = false
set_o.backup = false
set_o.undodir = os.getenv("HOME") .. "/.nvim/undodir"
set_o.undofile = true
-- MISC
set_opt.autochdir = true
set_opt.cmdheight = 0
set_opt.isfname:append { '@-@' }
set_o.termguicolors = true
set_opt.guicursor = {
  "n-v:block",
  "i-c-ci-ve:ver25",
  "r-cr:hor20",
  "o:hor50",
  "i:blinkwait700-blinkoff400-blinkon250-Cursor/lCursor",
  "sm:block-blinkwait175-blinkoff150-blinkon175",
}
-- Local window opt

vim.env.PATH = table.concat({ vim.fn.stdpath "data", "mason", "bin" }, "/") .. ":" .. vim.env.PATH
```
/home/fox/Dotfiles/.config/nvim/init.lua
```lua
require("fox-neovim-config")
```
You are my personal assistent, you should always try to keep this config as omptised as possible. Also if there are any mistakes, you should let me know.

